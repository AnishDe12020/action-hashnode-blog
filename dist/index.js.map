{"version":3,"file":"index.js","sources":["../webpack://action-hashnode-blog/./src/commit-file.js","../webpack://action-hashnode-blog/./src/display.js","../webpack://action-hashnode-blog/./src/helpers.js","../webpack://action-hashnode-blog/./src/query-hashnode.js","../webpack://action-hashnode-blog/../../../../../../Creative/nvm/v15.5.0/node_modules/@vercel/ncc/dist/ncc/@@notfound.js","../webpack://action-hashnode-blog/external \"child_process\"","../webpack://action-hashnode-blog/external \"fs\"","../webpack://action-hashnode-blog/external \"path\"","../webpack://action-hashnode-blog/webpack/bootstrap","../webpack://action-hashnode-blog/webpack/runtime/compat","../webpack://action-hashnode-blog/./src/index.js"],"sourcesContent":["const spawn = require( 'child_process' ).spawn;\r\nconst path  = require( \"path\" );\r\n\r\nconst exec = ( cmd, args = [] ) => new Promise( ( resolve, reject ) => {\r\n\tconst app = spawn( cmd, args, { stdio: 'inherit' } );\r\n\tapp.on( 'close', code => {\r\n\t\tif( code !== 0 ) {\r\n\t\t\terr      = new Error( `Invalid status code: ${code}` );\r\n\t\t\terr.code = code;\r\n\t\t\treturn reject( err );\r\n\t\t}\r\n\t\treturn resolve( code );\r\n\t} );\r\n\tapp.on( 'error', reject );\r\n} );\r\n\r\nconst main = async() => {\r\n\tawait exec( 'bash', [ path.join( __dirname, './commit.sh' ) ] );\r\n};\r\n\r\n\r\nmodule.exports = main;\r\n","const helpers = require( './helpers' );\n\nfunction blog_table( posts, style ) {\n\tlet column = style.split( '-' );\n\tcolumn     = ( typeof column[ 2 ] !== 'undefined' ) ? column[ 2 ] : 2;\n\n\tlet html = '<table><tr>';\n\n\tposts.forEach( ( post, index ) => {\n\t\tconst {url, title, brief, coverImage, dateUpdated, dateAdded} = post;\n\n\t\tif( 0 !== index && ( index % column ) === 0 ) {\n\t\t\thtml += '</tr><tr>';\n\t\t}\n\n\t\thtml += `<td>${helpers.img( coverImage, url, title, '', '' )}\n${helpers.a( url, title, `<strong>${title}</strong>` )}\n${dateAdded} ${dateUpdated}\n<br/> ${brief}</td>`;\n\t} );\n\n\treturn html += '</tr></table>';\n}\n\nasync function lists( posts, STYLE ) {\n\tlet markdown = [];\n\tSTYLE        = STYLE.toLowerCase();\n\tposts.forEach( ( post, index ) => {\n\t\tswitch( STYLE ) {\n\t\t\tcase 'list':\n\t\t\tcase 'list-unordered':\n\t\t\t\tmarkdown.push( `- [${post.title}](${post.url})` );\n\t\t\t\tbreak;\n\t\t\tcase 'list-ordered':\n\t\t\t\tmarkdown.push( `1. [${post.title}](${post.url})` );\n\t\t\t\tbreak;\n\t\t\tcase 'list-gist':\n\t\t\t\tmarkdown.push( `${index + 1}. ${post.title}` );\n\t\t\t\tbreak;\n\t\t}\n\n\t} );\n\treturn markdown.join( '\\n' );\n}\n\nasync function blog( posts, STYLE ) {\n\tlet markdown    = [];\n\tSTYLE           = STYLE.toLowerCase();\n\tlet isalternate = ( 'blog-alternate' === STYLE );\n\tSTYLE           = ( 'blog-alternate' === STYLE ) ? 'blog-left' : STYLE;\n\n\tif( STYLE.startsWith( 'blog-grid' ) ) {\n\t\treturn blog_table( posts, STYLE );\n\t}\n\n\tposts.forEach( post => {\n\t\tconst {url, title, brief, coverImage, dateUpdated, dateAdded} = post;\n\n\t\tswitch( STYLE ) {\n\t\t\tcase 'blog':\n\t\t\t\tmarkdown.push( `<h3>${helpers.a( url, title, title )}</h3>\n${helpers.img( coverImage, url, title, '', '400px' )}\n<div>Created: ${dateAdded}</div><div>Last Updated: ${dateUpdated}</div>\n<p>${brief}</p>` );\n\t\t\t\tbreak;\n\t\t\tcase 'blog-left':\n\t\t\tcase 'blog-right':\n\t\t\t\tlet align = ( 'blog-left' === STYLE ) ? 'left' : 'right';\n\t\t\t\tmarkdown.push( `<p align=\"left\">\n${helpers.img( coverImage, url, title, align, '250px' )}\n${helpers.a( url, title, `<strong>${title}</strong>` )}\n<div>Created: ${dateAdded}</div><div>Last Updated: ${dateUpdated}</div>\n<br/> ${brief} </p> <br/> <br/>` );\n\t\t\t\tif( isalternate ) {\n\t\t\t\t\tSTYLE = ( 'blog-left' === STYLE ) ? 'blog-right' : 'blog-left';\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\n\t} );\n\treturn markdown.join( `\\n` );\n}\n\nmodule.exports = {\n\tlist: lists,\n\tblog: blog\n};\n","function atag( link, title, content ) {\r\n\treturn ( link !== '' ) ? `<a href=\"${link}\" title=\"${title}\">${content}</a>` : content;\r\n}\r\n\r\nfunction imgtag( src, link, title, align, width ) {\r\n\twidth   = ( width !== '' ) ? `width=\"${width}\"` : '';\r\n\talign   = ( width !== '' ) ? `align=\"${align}\"` : '';\r\n\tlet alt = ( title !== '' ) ? `alt=\"${title}\"` : '';\r\n\treturn ( src !== '' ) ? atag( link, title, `<img src=\"${src}\" ${alt} ${width} ${align} />` ) : '';\r\n}\r\n\r\nmodule.exports = {\r\n\ta: atag,\r\n\timg: imgtag,\r\n\tpost_link: function( post, username, BLOG_URL = false ) {\r\n\t\treturn ( '' !== BLOG_URL ) ? `${BLOG_URL}/${post.slug}` : `https://${username}.hashnode.dev/${post.slug}-${post.cuid}`;\r\n\t},\r\n\timage_size: function( user_value, _default, small, large ) {\r\n\t\tif( 'small' === user_value ) {\r\n\t\t\treturn small;\r\n\t\t}\r\n\r\n\t\tif( 'large' === user_value ) {\r\n\t\t\treturn large;\r\n\t\t}\r\n\r\n\t\tif( '' === user_value ) {\r\n\t\t\treturn _default;\r\n\t\t}\r\n\t\treturn user_value;\r\n\t}\r\n};\r\n\r\n","const fetch           = require( \"node-fetch\" );\nconst helpers         = require( './helpers' );\nconst API_URL         = 'https://api.hashnode.com',\n\t  DEFAULT_HEADERS = {\n\t\t  'Content-type': 'application/json',\n\t  };\n\nasync function query_api( username = false, pageno = 1 ) {\n\tconst query       = `\n{\n  user(username: \"${username}\"){\n    publication{\n      posts(page:${pageno}) {\n        slug\n        title\n        cuid\n        brief\n        coverImage\n\t\tdateUpdated\n        dateAdded\n      }\n    }\n  }\n}\n`;\n\tconst result      = await fetch( API_URL, {\n\t\tmethod: 'POST',\n\t\theaders: DEFAULT_HEADERS,\n\t\tbody: JSON.stringify( { query } ),\n\t} );\n\tconst ApiResponse = await result.json();\n\n\tif( 0 === ApiResponse.data.user.publication.posts.length ) {\n\t\treturn false;\n\t}\n\n\treturn ApiResponse.data.user.publication.posts;\n}\n\nmodule.exports = async function( username, limit = 6, BLOG_URL = false ) {\n\tlet loop_status = true,\n\t\tposts       = [],\n\t\ti           = 0;\n\twhile( loop_status ) {\n\t\tlet results = await query_api( username, i++ );\n\n\t\tif( false === results ) {\n\t\t\tloop_status = false;\n\t\t} else {\n\t\t\tresults.forEach( ( post ) => {\n\t\t\t\tif( posts.length >= limit ) {\n\t\t\t\t\tloop_status = false;\n\t\t\t\t} else {\n\t\t\t\t\tpost.url = helpers.post_link( post, username, BLOG_URL );\n\t\t\t\t\tposts.push( post );\n\t\t\t\t}\n\t\t\t} );\n\t\t}\n\n\t\tif( posts.length >= limit ) {\n\t\t\tloop_status = false;\n\t\t}\n\t}\n\treturn posts;\n};\n",null,"module.exports = require(\"child_process\");;","module.exports = require(\"fs\");;","module.exports = require(\"path\");;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\tvar threw = true;\n\ttry {\n\t\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\t\tthrew = false;\n\t} finally {\n\t\tif(threw) delete __webpack_module_cache__[moduleId];\n\t}\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","\nif (typeof __webpack_require__ !== 'undefined') __webpack_require__.ab = __dirname + \"/\";","const query       = require( './query-hashnode' );\nconst render      = require( './display' );\nconst core        = require( '@actions/core' );\nconst fs          = require( \"fs\" );\nconst commitFile  = require( './commit-file' );\nconst { GistBox } = require( 'gist-box' );\n\n// most @actions toolkit packages have async methods\nasync function run() {\n\ttry {\n\t\tconst TYPE     = core.getInput( 'TYPE' );\n\t\tconst FILE     = core.getInput( 'FILE' );\n\t\tconst USERNAME = core.getInput( 'USERNAME' );\n\t\tconst STYLE    = core.getInput( 'STYLE' );\n\t\tconst COUNT    = core.getInput( 'COUNT' );\n\t\tconst BLOG_URL = core.getInput( 'BLOG_URL' );\n\n\t\tcore.startGroup( 'Parsed Config' );\n\t\tcore.info( `Type                     = ${TYPE}` );\n\t\tcore.info( `File / Gist ID           = ${FILE}` );\n\t\tcore.info( `Hashnode Username        = ${USERNAME}` );\n\t\tcore.info( `Output Style             = ${STYLE}` );\n\t\tcore.info( `No Of Posts To Display   = ${COUNT}` );\n\t\tcore.endGroup();\n\n\n\t\tconst results = await query( USERNAME.toLowerCase(), COUNT, BLOG_URL );\n\t\tlet output    = '';\n\n\t\tcore.startGroup( 'Latest Posts data' );\n\t\tcore.info( JSON.stringify( results, null, 2 ) );\n\t\tcore.endGroup();\n\t\tcore.info( ' ' );\n\n\t\tif( 'gist' === TYPE.toLowerCase() ) {\n\t\t\tif( STYLE.toLowerCase().startsWith( 'list' ) ) {\n\t\t\t\toutput = await render.list( results, STYLE );\n\t\t\t} else {\n\t\t\t\toutput = await render.list( results, 'list' );\n\t\t\t}\n\n\t\t\tlet list_data = await render.list( results, 'list-gist' );\n\t\t\tconst box     = new GistBox( { id: FILE, token: process.env.GITHUB_TOKEN } );\n\n\t\t\tawait box.update( {\n\t\t\t\tfilename: 'blog.md',\n\t\t\t\tdescription: 'My Latest Blogs ðŸ‘‡',\n\t\t\t\tcontent: list_data + '\\n\\n' + output\n\t\t\t} );\n\t\t} else {\n\t\t\tconst file_path    = `${process.env.GITHUB_WORKSPACE}/${FILE}`;\n\t\t\tconst file_content = fs.readFileSync( file_path );\n\n\t\t\tif( STYLE.toLowerCase().startsWith( 'list' ) ) {\n\t\t\t\toutput = await render.list( results, STYLE );\n\t\t\t} else if( STYLE.toLowerCase().startsWith( 'blog' ) ) {\n\t\t\t\toutput = await render.blog( results, STYLE );\n\t\t\t}\n\n\n\t\t\tconst regex  = /^(<!--(?:\\s|)HASHNODE_BLOG:(?:START|start)(?:\\s|)-->)(?:\\n|)([\\s\\S]*?)(?:\\n|)(<!--(?:\\s|)HASHNODE_BLOG:(?:END|end)(?:\\s|)-->)$/gm;\n\t\t\tconst result = file_content.toString().replace( regex, `$1\\n${output}\\n$3` );\n\n\t\t\tfs.writeFileSync( file_path, result );\n\n\t\t\tawait commitFile().catch( err => {\n\t\t\t\tcore.error( err );\n\t\t\t\tcore.info( err.stack );\n\t\t\t\tprocess.exit( err.code || -1 );\n\t\t\t} );\n\t\t}\n\n\t} catch( error ) {\n\t\tcore.setFailed( error.message );\n\t}\n}\n\nrun();\n"],"mappings":";;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;ACxFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;AClEA;AACA;AACA;A;;;;;AAFA;AACA;AACA;A;;;;;AAFA;AACA;AACA;A;;;;;;ACFA;AACA;A;;;;;;ACDA;AACA;A;;;;;;ACDA;AACA;A;;;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC7BA;AACA;;;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;A","sourceRoot":""}